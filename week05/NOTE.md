学习笔记

## CSS 计算

##### 收集 CSS 规则

- 遇到 style 标签时，把 CSS 规则保存起来，toybrowser 就不考虑 link improt 这种形式了。
- 调用 CSS Parser 来分析 CSS 规则 npm install css
- 分析 CSS 规则的格式

##### 添加调用

- 当我们穿件一个元素后，立即计算 CSS
- 理论上，当我们分析一个元素时，所有 CSS 规则已经收集完毕
- 在真实浏览器中，肯呢个遇到卸载 body 的 style 标签，需要重新 CSS 计算的情况，我们忽略。

##### 获取父元素序列

- 在 computeCSS 函数中，我们必须知道元素的所有父元素才能判断元素与规则是否匹配
- 我们从上一个步骤的 stack 里，可以获取本元素的所有父元素。
- 因为我们首先获取的是“当前元素”，所以我们获得和计算父元素匹配的顺序是从内到外的。div div #myid 从内向外

##### 选择器与元素的匹配

- 选择器也要从当前元素 从内向外匹配
- 复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列

##### 计算选择器与元素的匹配

- 根据选择器的类型和元素属性，计算是否与当前元素匹配
- 这里仅仅实现了三种基本选择器，实际的浏览器汇总要处理符合选择器

##### 生成 computed 属性

- 一旦选择器匹配，就应用选择器到元素上，形成 computedSytle

##### specificity 的计算逻辑

- priority 优先级，specificity 特征，专一性。
- CSS 规则是根据 specificity 和后来优先规则覆盖的
- specificity 是个四元组 越左边的权重越高
- 一个 CSS 规则的 specificity 根据包含的简单选择器相加而成

## layout 排版

##### 根据浏览器属性进行排版

- 预处理，flexdirection,wrap 具体的 width,height,top,left 等属性抽象成主轴交叉轴属性.

##### 收集元素进行(row)

- 根据主轴尺寸，把元素分进行
- 如果设置了 no-wrap，则强行分配进第一行

##### 计算主轴

- 找出所有 flex 元素
- 把主轴方向的剩余尺寸，按照比例分配给这些元素
- 若剩余空间为负数，所有 flex 元素为 0，等比压缩剩余元素

##### 计算交叉轴

- 根据每一行中最大元素尺寸计算行高
- 根据行高 flex-align 和 item-align，确定元素的具体位置

## 渲染

##### 绘制单个元素

- 绘制需要依赖一个图形环境，这里用 images
- 绘制是在一个 viewport 上进行的

##### 绘制 dom 树

- 递归的调用子元素的绘制方法来完成 dom 树的绘制
- 忽略了一些不需要的绘制节点
- 实际浏览器中，文字是绘制难点，需要依赖字体库，字体还要转成图片去渲染
- 在实际浏览器中，还会对一些图层做 compositing（合成）
